# 1. 魔法方法

魔法方法会在特定的情况下自动运行, 无需调用. 常用作: 内存空间开辟, 回收, 自检, 迭代, 赋值, 运算等相关操作.

定义方式: 以`__`开头和结尾, 且必须接受第一个变量为`self`的函数

# 2. 常用方法

## 2.1 类生命流程

### 2.1.1 类创建

#### > `__prepare__`

执行于`__new__`之前, 必须返回`dict`(包含需要创建类的属性和方法)

```python
@classmethod
def __prepare__(mcs, name, bases):
return dict
```

* msc:  `metaclass`, 创建类时基于的元类
* name:  `str`, 需要创建类的名字
* bases: `tuple`, 创建的类需要继承的类

#### > `__new__`

* 创建类对象时, 会调用元类中的此方法, 用于开辟创建子**类的内存空间**, 此函数结果为创建后的类.
* 实例化对象时,  会调用当前类中的此方法, 用于数据初始化.

```python
@staticmethod
def __new__(mcs, name, bases, attrs):
return class
```

* mcs: `class`,  创建类时基于的元类
* name: `str`, 需要创建的类的名称
* bases: `tuple`,  创建的类需要继承的类
* sttrs: `dict`, 创建类的信息: 方法, 属性, 描述信息等.

#### > `__init__subclass__`

当一个类被继承时, 在子类实例化时, 会调用此方法, 修改此函数可以达到控制子类的效果.

```python
def __init__subclass__(cls, **kwargs):
return cls
```

* cls: 子类对象
* kwargs: 以关键字参数传入的子类信息.

示例

```python
class Philosopher(object):

    @classmethod
    def __init_subclass__(cls, *args, **kwargs):
        print(cls, args, kwargs)
        super().__init_subclass__()
        for k, v in kwargs.items():
            setattr(cls, k, v)

class AustralianPhilosopher(Philosopher, default_name="Bruce"):
    pass

a = AustralianPhilosopher()
print(a.default_name)
```

输出

```python
<class '__main__.AustralianPhilosopher'> () {'default_name': 'Bruce'}
Bruce
```

### 2.1.2 实例对象创建

#### > `__call__`

* 类实例化时, 会调用元类中`__call__`方法, 用来为**实例对象**开辟内存空间. 此方法会调用当前类中的`__new__`, `__init__`用来数据初始化
* 实例化对象调用时, 会调用当前类中的`__call__`方法, 并执行当前类中的该函数.

```python
def __call__(cls, *args, **kwargs):
return object
```

* cls: `class`, 实例化的类对象
* args/kwargs: 拓展参数

#### > `__init__`

由`__call__`调用, 并实例化对象. **注意**: 此函数中不得使用`return`.

```python
def __init__(self, *args, **kwargs):
```

### 2.1.3 销毁

#### > `__del__`

在实例将被销毁时调用。`del x`是将引用计数-1, 引用计数为0时才会调用`__del__`

```python
def __del__(self):
return None
```

### 2.1.4 生命流程示例

```python
print("####################### 类对象创建 ###############################")


class Foo1(type):
    """元类"""

    @classmethod
    def __prepare__(mcs, name, bases):
        print(1, id(mcs), "__prepare__", name, bases)
        return {'__module__': '__main__', '__qualname__': 'Foo2'}

    @staticmethod
    def __new__(mcs, name, bases, attrs):
        print(1, id(mcs), "__new__", mcs, name, bases, attrs)
        rsp = super().__new__(mcs, name, bases, attrs)
        print(1, "over __new__")
        return rsp

    def __call__(cls, *args, **kwargs):
        print(1, id(cls), "__call__", args, kwargs)
        rsp = super().__call__(*args, **kwargs)
        print(1, id(rsp), "__call__")
        return rsp

    def __del__(self):
        print(1, "__del__")


class Foo2(metaclass=Foo1):
    """父类"""

    def __new__(cls, *args, **kwargs):
        print(2, id(cls), "__new__", cls)
        res = super().__new__(cls)
        print(2, "over __new__")
        return res

    @classmethod
    def __init_subclass__(cls, **kwargs):
        print(2, id(cls), "__init__subclass__")
        rsp = super().__init_subclass__()
        print(2, "over __init_subclass__")
        return rsp

    def __del__(self):
        print(2, "__del__")


class Foo3(Foo2):
    """子类"""

    def __init__(self):
        print(3, id(self), "__init__")

    def __del__(self):
        print(3, "__del__")


print("######################## 实例对象创建 ##############################")
f3 = Foo3()
print(id(f3), id(Foo3))
```

输出

```python
####################### 类对象创建 ###############################
1 1735015494968 __prepare__ Foo2 ()
1 1735015494968 __new__ <class '__main__.Foo1'> Foo2 () {'__module__': '__main__', '__qualname__': 'Foo2', '__doc__': '父类', '__new__': <function Foo2.__new__ at 0x00000193F741A048>, '__init_subclass__': <classmethod object at 0x00000193F07B7C88>, '__del__': <function Foo2.__del__ at 0x00000193F7515BF8>, '__classcell__': <cell at 0x00000193F750B438: empty>}
1 over __new__
1 1735015494968 __prepare__ Foo3 (<class '__main__.Foo2'>,)
1 1735015494968 __new__ <class '__main__.Foo1'> Foo3 (<class '__main__.Foo2'>,) {'__module__': '__main__', '__qualname__': 'Foo3', '__doc__': '子类', '__init__': <function Foo3.__init__ at 0x00000193F7515C80>, '__del__': <function Foo3.__del__ at 0x00000193F7515D08>}
2 1735015486472 __init__subclass__
2 over __init_subclass__
1 over __new__
######################## 实例对象创建 ##############################
1 1735015486472 __call__ () {}
2 1735015486472 __new__ <class '__main__.Foo3'>
2 over __new__
3 1734906444992 __init__
1 1734906444992 __call__
1734906444992 1735015486472
1 1735015486472 __call__ () {}
2 1735015486472 __new__ <class '__main__.Foo3'>
2 over __new__
3 1734906445608 __init__
1 1734906445608 __call__
3 __del__
1 __del__
3 __del__
1 __del__
```

## 2.2 类型转换

### 2.2.1 迭代类型

#### > `__iter__`

使用`iter`方法会调用此方法, 将会返回一个迭代器. `Iterator`中包含这种方法, 可以直接继承使用, 默认返回`self`

```python
def __iter__(self):
return iterable
```

#### > `__next__`

使用`next`方法会调用此方法, 用来获取迭代器的下一个值. `Iterable`中包含此种方法, 可以直接继承使用

```python
def __next__(self):
return object[从__iter__获取迭代器的下一个值]
```

**示例**

```python
from collections.abc import Iterable, Iterator


class Foo(object):

    def __init__(self):
        self.__array = None

    def __iter__(self):
        def iterable():
            for i in range(1, 20):
                yield i

        self.__array = iterable()
        return self.__array

    def __next__(self):
        return next(self.__array)


a = Foo()
print([b for b in a])
print(isinstance(a, Iterable))
print(isinstance(a, Iterator))
```

输出

```python
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
True
True
```

### 2.2.2 切片类型

#### > `__getitem__`

用于切片取值或者索引取值

```python
def __getitem__(self, key):
return object
```

* key: `可hash类型`, 切片或者索引值

#### > `__setitem__`

用于切片赋值或者索引赋值

```python
def __setitem__(self, key, value):
return None
```

* key: `可hash类型`, 切片或者索引值
* value: `object`, 对应的赋值

#### > `__delitem__`

用于切片删除或者索引删除

```python
def __delitem__(self, key):
return None
```

* key: `可hash类型`, 切片或者索引值

#### > `__reversed__`

翻转操作, 调用`reversed()`时, 会调用此函数. 如果此方法不存在, 则会调用两个方法:

* `__len__`, 确认容器长度
* `__getitem__`, 翻转容器

```python
def __reversed__(self):
return iterable
```

#### > `__contains__`

判断某个元素时候存在容器中, 使用`in`时会调用此方法. 如果此方法不存在, 则会调用两个方法:

* `__iter__`, 获取可迭代对象, 如果不存在则调用
* `__getitem__`方法

```python
def __contains__(self, item):
return bool
```

* item: `object`, 需要对比的对象

#### > `__len__`

获取容器长度, 一般`len()`执行时会调用此方法

```python
def __len__(self):
return int
```



**示例**

​	示例中使用的是`list`, 字典等其他类型, 同理

```python
class Foo(object):

    def __init__(self):
        self.__array = list(range(1, 5))

    def __getitem__(self, item):
        print(item)
        return self.__array[item]

    def __delitem__(self, key):
        del self.__array[key]

    def __setitem__(self, key, value):
        self.__array[key] = value

    def __str__(self):
        return str(self.__array)

    def __len__(self):
        return len(self.__array)
    
    # def __reversed__(self):
    #     return reversed(self.__array)

    # def __contains__(self, item):
        # return item in self.__array



a = Foo()
print(a[1:3])
a[2] = 3
print(a)
del a[1]
print(a)
# print(list(reversed(a)))
print(1 in a)
```

输出

```python
slice(1, 3, None)
[2, 3]
[1, 2, 3, 4]
[1, 3, 4]
0
True
```

### 2.2.3 非容器类型

#### > `__str__`

用于转换字符串, 执行`str()`时会调用此方法.

```python
def __str__(self):
return str
```

#### > `__bytes__`

用于二进制转换, 执行`bytes()`时会调用

```python
def __bytes__(self):
return bytes
```

#### > `__bool__`

用于`bool`转换, 执行`bool()`时会被调用. 如果此方法未被定义, 则:

* 调用`__len__`, 判断长度

```python
def __len__(self):
return bool
```



### 2.2.4 其他操作

#### > `__format__`

类似`format`, 主要用于占位符带入.

```python
def __format__(self, format_spec):
return str
```

* format_spec: `format占位信息`, 同`format`用法

#### > `__repr__`

对象信息描述, 常用语交互环境输出, 对象序列化展示等操作, 一般调用`repr()`时会执行. 当此方法不存在时

* 调用`__str__`方法

```python
def __repr__(self):
return str
```

#### > `__hash__`

用于hash操作, 执行`hash()`时会被调用. 注意:

* 对象中必须定义`__eq__`方法
* 对象不能为可变类型, 只能为不可变类型
* `__hash__`返回值不能为`None`, 否则系统进行`isinstance(object, collections.abc.Hashable)`不能通过

```python
def __hash__(self):
return Hashable
```



## 2.3 自省

### 2.3.1 属性

#### - `__mro__`

返回类组成的元组, 在mro查找期间会基于此方法进行

### 2.3.2 方法

## 2.4 数学运算

### 2.4.1 比较运算

### 2.4.2 算法运算

## 2.5 上下文

#### > `__enter__`

开启上文, 一般调用`with`语法时会调用此函数

```python
def __enter__(self):
return object
```

#### > `__exit__`

开启下文, 一般程序离开上下文时执行. 返回值为空表示异常不进行处理, 否则表示异常已经处理, 异常不在向上冒泡.

```python
def __exit__(self, exc_type, exc_val, exc_tb):
return None
```

* exc_type: `class`, 异常的类型
* exc_value: `str`, 异常的信息
* exc_tb: `object`, 异常回溯信息

**示例**:

```python
class Foo(object):

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        print(exc_type, exc_val, exc_tb)


with Foo():
    raise ValueError("xxx")
```

输出

```python
<class 'ValueError'> xxx <traceback object at 0x000002684284F748>
Traceback (most recent call last):
  File "E:/project/test/t_builtins/test.py", line 148, in <module>
    raise ValueError("xxx")
ValueError: xxx
```

# 3. 其他方法

#### > `__mro_entries__`

此方法必须返回类的元组以代替基类被使用. 元组可以为空, 在此情况下原始基类将会被忽略. 主要用于非继承type类型的类批量同步继承关系

```python
def __mro_entries__(bases):
return tuple
```

* bases: `tuple`, 继承的类

#### > `__length_hint__`

基于`operator`模块创建的魔法方法, 用于简单校验函数长度

# 4. 魔法方法案例

## 4.1 单例模式

问题: 

* **注意**: 问题提出基于**非多进程**环境

* 每次类实例化都会创建一个对象, 当需要多出使用公用一个实例时, 就会出现局限性.
* 如果每次都`from xx import xx`容易引起循环导入问题, 可不可以直接让类每次的实例化都产生同一个对象?

单例模式: 让每次类的实例化都产生同一个对象, 解决实例化对象多出调用问题.

### 4.1.1 基于元类

原理:

* 修改`__call__`魔法方法, 只允许调用一次子类实例化时的内存空间开辟
* 修改`__new__`魔法方法, 用来记录子类实例化的对象

特点:

* 较为复杂
* 从根源上解决子类实例化的内存空间创建.
* 更彻底, 实例化对象时, 不会重复调用`__init__`

```python
class SingletonMetaClass(type):

    @staticmethod
    def __new__(mcs, name, bases, attrs):
        attrs["_instance"] = None
        return super().__new__(mcs, name, bases, attrs)

    def __call__(cls, *args, **kwargs):
        print("params: ", args, kwargs)
        if cls._instance is None:
            cls._instance = super().__call__(*args, **kwargs)
        print("create instance success!")
        return cls._instance


class Singleton(metaclass=SingletonMetaClass):
    pass


class User(Singleton):
    def __init__(self, a=None, b=None):
        print("__init__")
        self.a = a
        self.b = b


print(id(Singleton), id(User), id(User(1, 2)))  # 第一次实例化   a = 1
print(id(User()))  # 第二次  a = 1
print(User().a)  # 第三次   a = 1
```

输出

```python
params:  (1, 2) {}
__init__
create instance success!
2153411621736 2153411598136 2153302293976
params:  () {}
create instance success!
2153302293976
params:  () {}
create instance success!
1
```



### 4.1.2 基于object

原理:

* 基于父类实例化对象返回的拦截, 在调用`__new__`时, 选择性返回实例化对象. 注意此时新的实例化对象已经创建了, 只是进行了舍弃.
* 较为简单, 但是重复实例化对象时, 会重复的`__init__`的参数进行赋值.

```python
class Singleton(object):
    @staticmethod
    def __new__(cls, *args, **kwargs):
        print(id(cls), "Singleton.__new__")
        cls._instance = getattr(cls, "_instance", None) or object.__new__(cls)
        return cls._instance


class User(Singleton):
    def __init__(self, a=None, b=None):
        self.a = a
        self.b = b


print(id(Singleton), id(User), id(User(1, 2)))     # 第一次实例化位置  a=1
print(id(User()))   # 第二次  a = None   被覆盖了
print(User().a)   # 第三次  a = None   又被覆盖了

```

输出

```python
2003270606936 Singleton.__new__
None
__init__
2003270611656 2003270606936 2003161509448
2003270606936 Singleton.__new__
1
__init__
2003161509448
2003270606936 Singleton.__new__
None
__init__
None
```

