# 1. 路由

flask是采用路由装饰器模式, 来维护一个字典

key为endpoint或者可以理解为url, value为视图函数

## 1.1 增加路由

flask增加路由有两种方式, 一种为装饰器, 另一种为直接增加

### 1.1.1 装饰器

```python
app.route(self, rule, endpoint, *options)
```

**说明:**

* rule

  url资源路径

* endpoint

  映射关系, url直接对应的是endpoint, endpoint直接对应view_function, 可以用app.url_map对应关系查看, url没有直接和view_function存在直接的映射关系, 而是通过endpoint中转出来的映射关系, 所以一般重定向时可以直接用endpoint:
      url_for(endpoint)
      url_for(蓝图_app.endpoint)

* *options

  * method

    list, 默认为`["GET"]`. 表示此方法接受的类型
    
    

**示例**

```python
@app.route("/test2", endpoint="test2", view_func=test2)
def test2():
    return "test2"
```



### 1.1.2 直接增加

```python
app.add_url_rule(self, rule, endpoint=None, view_func=None, provide_automatic_options=None, **options)
```

**说明:**

* rule

  url资源路径

* endpoint

  映射关系, url直接对应的是endpoint, endpoint直接对应view_function, 可以用app.url_map对应关系查看, url没有直接和view_function存在直接的映射关系, 而是通过endpoint中转出来的映射关系, 所以一般重定向时可以直接用endpoint:
      url_for(endpoint)
      url_for(蓝图_app.endpoint)

* view_func

  视图函数

* provide_automatic_options

  是否自动向method中添加OPTIONS参数

* *options

  * method

    list, 默认为`["GET"]`. 表示此方法接受的类型

    

 **示例** 

```python
def test1():
    return "test1"

app.add_url_rule("/test1", endpoint="test1", view_func=test1)
```

##