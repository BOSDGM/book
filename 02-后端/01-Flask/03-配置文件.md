# 1. 配置导入

为了保证全局变量可以最快定位或变更, 需要将其写入配置中. 一般在flask常用的是对象或者文本导入

## 1.1 对象

```python
class Config(object):
    DEBUG = True
    # 重写父类类属性, 1. 让错误信息显示出来; 2. 还能检测到代码变动时, 自动重启服务器
    AAA = "xx"
    # 这里的变量不论是否大写, 在使用的是否都会转换成大写的
    a = "aa"

app.config.from_object(Config)

# def from_object(self, obj)
```



## 1.2 文本

```python
# config.cfg 文件名称随意取名字, 内容是要重写的配置信息
​```
DEBUG = True
AAA = "xx"
a = "aa"  # 小写参数不识别, 直接被抛弃了
​```

app.config.from_pyfile("config.cfg")   # 名字和取得名字统一

# def from_pyfile(self, filename, silent=False)
# silent: 如果没有找到filename, 是否忽略此错误
```



## 1.3 json

```python
# config.json
​```
{
  "DEBUG": true,
  "AAA": "aaa",
  "a": "a"  # 小写的无法识别, 直接返回None
}
​```

app.config.from_json("config.json")

# from_json(self, filename, silent=False)
```



## 1.4 其他

* from_envvar

  ```python
  app.config.from_envvar("APPS")  # 首先在变量中配置APPS, 然后在程序内部调用即可
  
  # def from_envvar(variable_name, silent=False)
  ```

  

* from_mapping

  ```python
  app.config.from_mapping([("APPS", "app"), ("BASE", 1)], A=2})
  
  # def from_mapping(self, *mapping, **kwargs)
  # mapping: items/dict, 
  # kwargs: 关键字参数, 例如debug=True
  ```

  

# 2. flask参数配置

## 2.1 内置参数

```python
# 调试模式
DEBUG=False
# 测试模式
TESTING=False
# 出现错误时是否向前端发送异常信息, 如果在debug/test模式默认为True, 生产模式默认为None
PROPAGATE_EXCEPTIONS
# 是否强制异常时, 请求上下文出栈
PRESERVE_CONTEXT_ON_EXCEPTION=False
# 秘钥
SECRET_KEY
# session令牌名称
SESSION_COOKIE_NAME
# session作用域, 默认全子域都有效
SESSION_COOKIE_DOMAIN
# session作用url, 默认对APPLICATION_ROOT的全部路径有效
SESSION_COOKIE_PATH
# session是否只支持http
SESSION_COOKIE_HTTPONLY=True
# session是否设置安全标识
SESSION_COOKIE_SECURE=False
# session回话有效期(s)
PERMANENT_SESSION_LIFETIME
# session是否每次请求都刷新
SESSION_REFRESH_EACH_REQUEST=False
# x-sendfile
USE_X_SENDFILE
# 日志记录器名称
LOGGER_NAME
# 设置域名和端口
SERVER_NAME
# 应用所在的路径
APPLICATION_ROOT
# 服务器允许请求的最大长度
MAX_CONTENT_LENGTH
# 缓存静态文件时间(s)
SEND_FILE_MAX_AGE_DEFAULT=43200
# 是否让HTTP访问中的异常抛出
TRAP_HTTP_EXCEPTIONS=False
# 是否关闭werkzeug详细的异常回溯
TRAP_BAD_REQUEST_ERRORS=False
# url模式选择
PREFERRED_URL_SCHEME="http"
# 使用ASCII序列化json数据
JSON_AS_ASCII=True
# 按照原来数据的key序列化数据, 并保证了key的顺序
JSON_SORT_KEYS
# 是否开启json字符串, 规整打印
JSONIFY_PRETTYPRINT_REGULAR=False
```



## 2.2 三方参数

### 2.2.1 flask-sqlalchemy

```python
# 数据库配置
    # mysql+pymysql://username:password@127.0.0.1:3306/test
	# postgresql://scott:tiger@localhost/mydatabase
	# - oracle://scott:tiger@127.0.0.1:1521/sidname
	# sqlite:////absolute/path/to/foo.db
SQLALCHEMY_DATABASE_URI = "mysql://username:password@ip:port/db_name"
# 绑定多个数据库
SQLALCHEMY_BINDS = {
	"db1": "mysql://username:password@ip:port/db_name",
    "db2": "sqlite:////path/to/appmeta.db"
}
# 是否开启查询语句显示
SQLALCHEMY_ECHO=False
# 是否读取每一句查询语句的具体信息(利用flask_sqlalchemy.get_debug_queries()语句/执行时长等)
SQLALCHEMY_RECORD_QUERIES=False # 测试/debug=True默认自动打开的
# 是否禁用UNICODE编码
SQLALCHEMY_NATIVE_UNICODE=False
# 数据库连接池
SQLALCHEMY_POOL_SIZE=5
# 数据库连接池超时(s)
SQLALCHEMY_POOL_TIMEOUT=10
# 数据库连接收回(s)
SQLALCHEMY_POOL_RECYCLE=2 * 60 * 60
# 超出连接池最大值可创建的额外连接数, 使用后将会被抛弃
SQLALCHEMY_MAX_OVERFLOW
# 是否关闭信号追踪:
	# https://blog.csdn.net/weixin_42225318/article/details/80984198
	注: flask提供了信号追踪的接口(flask.signals最后几行), 需要先安装pip install blinker
    用途: 
        1. 检测各种请求钩子的调用, 并返回调用对象处理结果
        2. sqlalchemy对信号支持, 检测数据库的增删改操作, 并返回操作对象和list[(操作对象, "insert/delete/update")]
        3. 关闭可以提高服务器性能
        4. 对两个装饰函数有用:
            before_models_committed/models_committed
SQLALCHEMY_TRACK_MODIFICATIONS=False
```







